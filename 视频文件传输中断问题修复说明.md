# 视频文件传输中断问题修复说明

## 问题描述
在传输大型视频文件时，可能会出现传输中断的问题，导致文件传输失败。

## 解决方案

本次修复通过以下四个关键技术手段解决了视频文件传输中断的问题：

### 1. ✅ 实现 readFully() 方法（已优化）

**位置**: [`FileTransferManager.kt`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:455) 第455-497行

**功能**: 确保完整读取指定字节数的数据，避免部分读取导致的数据不完整。

**实现细节**:
- 循环读取直到获取完整数据
- 支持重试机制（最多3次）
- 处理读取返回0字节的情况
- 详细的日志记录

```kotlin
private fun readFully(inputStream: InputStream, buffer: ByteArray, offset: Int, length: Int): Int {
    var totalRead = 0
    var retryCount = 0
    
    while (totalRead < length && retryCount < MAX_RETRY_COUNT) {
        // 读取逻辑...
    }
    return totalRead
}
```

### 2. ✅ Socket 超时 + 后台保活（WakeLock）

**位置**: [`FileTransferManager.kt`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:1)

**新增功能**:

#### WakeLock 管理
- **acquireWakeLock()**: 获取 WakeLock，防止设备休眠中断传输
- **releaseWakeLock()**: 传输完成后释放 WakeLock
- 超时时间设置为10分钟

```kotlin
private fun acquireWakeLock() {
    val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
    wakeLock = powerManager.newWakeLock(
        PowerManager.PARTIAL_WAKE_LOCK,
        "NFCBeam::FileTransferWakeLock"
    ).apply {
        acquire(10 * 60 * 1000L) // 10分钟超时
    }
}
```

#### Socket 超时设置
- 将 `SOCKET_TIMEOUT_MS` 从 30秒 增加到 **60秒**
- 在传输开始前测试 Socket 连接状态
- 添加连接异常检测

**调用位置**:
- [`startFileTransfer()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:188): 开始传输时获取 WakeLock
- [`startFileReceiver()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:548): 开始接收时获取 WakeLock
- [`performFileTransfer()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:150) 和 [`receiveFiles()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:584) 的 finally 块: 释放 WakeLock

### 3. ✅ 大文件预拷贝到 cache

**位置**: [`FileTransferManager.kt`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:138)

**新增方法**: [`preCopyLargeFileToCache(uri: Uri, fileSize: Long): Uri`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:138)

**功能**: 
- 检测大文件（>50MB）
- 将大文件预先拷贝到应用缓存目录
- 避免在传输过程中因 URI 权限问题导致读取失败

**实现细节**:
```kotlin
private fun preCopyLargeFileToCache(uri: Uri, fileSize: Long): Uri {
    if (fileSize < LARGE_FILE_THRESHOLD) {
        return uri // 小文件直接返回原 URI
    }
    
    // 创建缓存目录
    val cacheDir = File(context.cacheDir, "large_files")
    cacheDir.mkdirs()
    
    // 拷贝文件到缓存
    // ... 拷贝逻辑，每10MB记录一次进度
    
    return Uri.fromFile(cacheFile)
}
```

**使用位置**:
- [`performFileTransfer()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:150): 在传输每个文件前检查是否需要预拷贝

### 4. ✅ 调用 takePersistableUriPermission

**位置**: [`FileTransferManager.kt`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:124)

**新增方法**: [`takePersistableUriPermission(uri: Uri)`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:124)

**功能**: 
- 请求持久化 URI 权限
- 确保在传输过程中 URI 权限不会失效
- 特别适用于通过文件选择器获取的 URI

**实现细节**:
```kotlin
private fun takePersistableUriPermission(uri: Uri) {
    try {
        val takeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION
        context.contentResolver.takePersistableUriPermission(uri, takeFlags)
        Log.d(TAG, "✅ 已获取持久化 URI 权限: $uri")
    } catch (e: SecurityException) {
        Log.w(TAG, "无法获取持久化 URI 权限: $uri", e)
    }
}
```

**使用位置**:
- [`startFileTransfer()`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:188): 在开始传输前为所有文件 URI 请求持久化权限

## 权限配置

### AndroidManifest.xml 新增权限

```xml
<uses-permission android:name="android.permission.WAKE_LOCK" />
```

此权限用于支持 WakeLock 功能，防止设备在传输过程中休眠。

**位置**: [`AndroidManifest.xml`](app/src/main/AndroidManifest.xml:20)

## 技术参数

| 参数 | 原值 | 新值 | 说明 |
|------|------|------|------|
| SOCKET_TIMEOUT_MS | 30000ms | 60000ms | Socket 超时时间增加到60秒 |
| LARGE_FILE_THRESHOLD | - | 50MB | 大文件阈值，超过此大小会预拷贝 |
| WakeLock 超时 | - | 10分钟 | WakeLock 自动释放时间 |

## 传输流程优化

### 发送端流程
1. 请求所有文件的持久化 URI 权限
2. 获取 WakeLock
3. 检测 Socket 连接状态
4. 对于大文件（>50MB），预拷贝到缓存
5. 逐个传输文件
6. 传输完成后释放 WakeLock

### 接收端流程
1. 获取 WakeLock
2. 检测 Socket 连接状态
3. 使用 readFully() 确保完整读取数据
4. 接收完成后释放 WakeLock

## 日志增强

新增了详细的日志记录：
- ✅ WakeLock 获取/释放状态
- ✅ Socket 连接测试结果
- 📦 大文件预拷贝进度
- ✅ URI 权限获取状态

## 错误处理

所有新增功能都包含完善的错误处理：
- WakeLock 获取失败不影响传输继续
- URI 权限请求失败会记录警告但不中断流程
- 大文件预拷贝失败会回退到使用原 URI
- Socket 连接测试失败会抛出明确的异常

## 测试建议

1. **小文件测试** (<50MB): 验证基本传输功能
2. **大文件测试** (>50MB): 验证预拷贝功能
3. **长时间传输测试**: 验证 WakeLock 防休眠功能
4. **网络不稳定测试**: 验证 readFully() 重试机制
5. **权限测试**: 验证 URI 持久化权限功能

## 兼容性

- ✅ Android 6.0+ (API 23+)
- ✅ 支持所有文件类型
- ✅ 向后兼容现有功能

## 性能影响

- **内存**: 大文件预拷贝会占用缓存空间，但传输完成后可清理
- **CPU**: WakeLock 会略微增加电量消耗，但仅在传输期间
- **传输速度**: 大文件预拷贝会增加初始延迟，但提高传输稳定性

## 总结

通过以上四个关键技术手段的实施，显著提高了视频文件传输的稳定性和可靠性：

1. ✅ **readFully()** - 确保数据完整性
2. ✅ **WakeLock + Socket 超时** - 防止传输中断
3. ✅ **大文件预拷贝** - 避免 URI 访问问题
4. ✅ **持久化 URI 权限** - 确保权限不失效

这些改进共同作用，有效解决了视频文件传输中断的问题。