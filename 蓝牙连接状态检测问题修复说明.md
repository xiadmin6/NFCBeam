# 蓝牙连接状态检测问题修复说明

## 问题描述

在 NFCBeam 项目中，用户报告了一个问题：**明明已经建立了蓝牙连接，但是在选择传输文件的时候提示蓝牙未连接**。

## 根本原因分析

### 问题1：异步连接时序问题

**错误的流程：**
1. 蓝牙 OOB 配对完成 → `onPairingCompleted()` 被调用
2. 调用 `onBluetoothConnectionRequested()` → 设置 `isNfcConnected = true` ❌
3. `HomeScreen` 的 `LaunchedEffect` 检测到 `isNfcConnected = true` → 自动跳转到文件选择页面
4. **此时 `bluetoothManager.connectToDevice()` 还在异步执行中，Socket 尚未建立！**
5. 用户选择文件 → 调用 `startFileTransfer()` → Socket 为 null 或未连接 → 提示"蓝牙未连接"

**问题所在：**
- [`MainActivity.kt:598`](app/src/main/java/com/example/nfcbeam/MainActivity.kt:598) 在 `onBluetoothConnectionRequested()` 中过早设置 `isNfcConnected = true`
- 此时只是**请求建立连接**，Socket 连接是异步的，尚未完成
- [`BluetoothManager.connectToDevice()`](app/src/main/java/com/example/nfcbeam/BluetoothManager.kt:255) 在后台线程中执行，需要时间
- 但 UI 已经跳转到文件选择页面，用户可以立即选择文件

### 问题2：不可靠的连接检测

**原有代码（FileTransferManager.kt:88）：**
```kotlin
if (socket == null || !socket.isConnected) {
    // 提示蓝牙未连接
}
```

**问题：**
- `BluetoothSocket.isConnected` 方法在某些设备上不可靠
- 即使 Socket 已连接，该方法可能返回 false

## 修复方案

### 修复1：正确的连接状态同步

**修改文件：** [`MainActivity.kt`](app/src/main/java/com/example/nfcbeam/MainActivity.kt)

#### 1.1 在 Socket 真正连接成功后才设置连接状态

**修改位置：** [`MainActivity.kt:146-164`](app/src/main/java/com/example/nfcbeam/MainActivity.kt:146-164)

```kotlin
override fun onDeviceConnected(device: android.bluetooth.BluetoothDevice) {
    Log.d("Bluetooth", "✅ 蓝牙Socket连接成功: ${device.name}")
    
    // 重要：只有在 Socket 真正连接成功后，才设置 isNfcConnected = true
    // 这样 HomeScreen 的 LaunchedEffect 才会触发自动跳转
    isNfcConnected = true
    
    // 蓝牙连接成功后，根据模式开始相应的传输流程
    if (isSenderMode) {
        // 发送端：Socket连接成功后，HomeScreen 会自动跳转到文件选择页面
        Log.d("Bluetooth", "发送端蓝牙Socket连接成功，等待自动跳转到文件选择页面")
    } else {
        // 接收端：连接成功后跳转到传输页面并开始接收文件
        currentScreen = Screen.TRANSFER_IN_PROGRESS
        transferStatus = FileTransferManager.TransferStatus(isConnecting = false, isTransferring = true)
        fileTransferManager.startFileReceiver()
        Log.d("Bluetooth", "接收端蓝牙连接成功，跳转到传输页面并开始接收文件")
    }
}
```

#### 1.2 移除过早的连接状态设置

**修改位置：** [`MainActivity.kt:581-611`](app/src/main/java/com/example/nfcbeam/MainActivity.kt:581-611)

```kotlin
override fun onBluetoothConnectionRequested(device: android.bluetooth.BluetoothDevice) {
    val deviceName = if (connectGranted) {
        device.name ?: "Unknown Device"
    } else {
        "Unknown Device"
    }
    
    Log.d("OOBPairing", "配对成功，请求建立蓝牙Socket连接: $deviceName / ${device.address}")
    
    // 重要：不要在这里设置 isNfcConnected = true
    // 只有在 Socket 真正连接成功后（onDeviceConnected 回调）才设置
    // 这里只更新设备名称
    bluetoothDeviceName = deviceName
    
    // 建立实际的蓝牙Socket连接（异步操作）
    if (isSenderMode) {
        bluetoothManager.connectToDevice(device.address)
        Log.d("OOBPairing", "发送端正在异步建立Socket连接到设备: ${device.address}")
    } else {
        Log.d("OOBPairing", "接收端已启动服务器，等待发送端Socket连接")
    }
}
```

### 修复2：改进连接检测逻辑

**修改文件：** [`FileTransferManager.kt:81-119`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt:81-119)

```kotlin
fun startFileTransfer(fileUris: List<Uri>) {
    if (isTransferring) {
        Toast.makeText(context, "传输正在进行中", Toast.LENGTH_SHORT).show()
        return
    }
    
    val socket = bluetoothManager.getClientSocket()
    if (socket == null) {
        Log.e(TAG, "蓝牙Socket为null，无法开始传输")
        mainHandler.post {
            transferListener?.onTransferError("蓝牙未连接")
            Toast.makeText(context, "蓝牙未连接", Toast.LENGTH_SHORT).show()
        }
        return
    }
    
    // 验证Socket连接状态 - 通过尝试获取流来确认
    try {
        val testInputStream = socket.inputStream
        val testOutputStream = socket.outputStream
        if (testInputStream == null || testOutputStream == null) {
            Log.e(TAG, "无法获取Socket输入输出流，连接可能未建立")
            mainHandler.post {
                transferListener?.onTransferError("蓝牙连接异常")
                Toast.makeText(context, "蓝牙连接异常", Toast.LENGTH_SHORT).show()
            }
            return
        }
        Log.d(TAG, "蓝牙Socket连接正常，输入输出流可用")
    } catch (e: Exception) {
        Log.e(TAG, "验证蓝牙连接失败: ${e.message}", e)
        mainHandler.post {
            transferListener?.onTransferError("蓝牙连接验证失败: ${e.message}")
            Toast.makeText(context, "蓝牙连接验证失败", Toast.LENGTH_SHORT).show()
        }
        return
    }
    
    // ... 继续传输逻辑
}
```

## 修复后的正确流程

### 发送端流程

```
1. 用户点击"蓝牙配对"按钮
   ↓
2. 开始 BLE 扫描，发现接收端设备
   ↓
3. OOB 配对完成 → onPairingCompleted()
   ↓
4. 请求建立 Socket 连接 → onBluetoothConnectionRequested()
   - 调用 bluetoothManager.connectToDevice() (异步)
   - 此时 isNfcConnected 仍为 false ✅
   ↓
5. Socket 连接成功 → onDeviceConnected()
   - 设置 isNfcConnected = true ✅
   ↓
6. HomeScreen 的 LaunchedEffect 检测到 isNfcConnected = true
   - 自动跳转到文件选择页面 ✅
   ↓
7. 用户选择文件
   ↓
8. 调用 startFileTransfer()
   - Socket 已就绪 ✅
   - 验证通过，开始传输 ✅
```

### 接收端流程

```
1. 用户点击"蓝牙配对"按钮
   ↓
2. 启动蓝牙服务器 + BLE 广告
   ↓
3. 发送端连接 → OOB 配对完成
   ↓
4. Socket 连接建立 → onDeviceConnected()
   - 设置 isNfcConnected = true
   - 直接跳转到传输页面
   - 开始接收文件 ✅
```

## 关键改进点

### 1. 连接状态同步
- ✅ `isNfcConnected` 只在 Socket 真正连接成功后设置
- ✅ 避免了异步连接导致的时序问题
- ✅ 确保跳转到文件选择页面时 Socket 已就绪

### 2. 可靠的连接验证
- ✅ 不依赖不可靠的 `isConnected` 方法
- ✅ 通过获取输入输出流来验证连接
- ✅ 提供详细的错误信息

### 3. 清晰的日志
- ✅ 添加详细的日志输出
- ✅ 区分不同的连接阶段
- ✅ 便于调试和问题排查

## 修复效果

### 修复前
- ❌ 配对完成后立即跳转，Socket 尚未建立
- ❌ 用户选择文件时 Socket 为 null
- ❌ 提示"蓝牙未连接"错误
- ❌ 无法开始文件传输

### 修复后
- ✅ 等待 Socket 真正连接成功后才跳转
- ✅ 用户选择文件时 Socket 已就绪
- ✅ 连接状态检测准确可靠
- ✅ 文件传输正常进行

## 相关文件

### 修改的文件
1. **[`app/src/main/java/com/example/nfcbeam/MainActivity.kt`](app/src/main/java/com/example/nfcbeam/MainActivity.kt)**
   - 修改 `onDeviceConnected()` 回调（第 146-164 行）
   - 修改 `onBluetoothConnectionRequested()` 回调（第 581-611 行）

2. **[`app/src/main/java/com/example/nfcbeam/FileTransferManager.kt`](app/src/main/java/com/example/nfcbeam/FileTransferManager.kt)**
   - 修改 `startFileTransfer()` 方法（第 81-119 行）

### 相关类
- [`BluetoothManager.kt`](app/src/main/java/com/example/nfcbeam/BluetoothManager.kt) - 管理蓝牙连接
- [`HomeScreen.kt`](app/src/main/java/com/example/nfcbeam/ui/screens/HomeScreen.kt) - 监听连接状态并自动跳转

## 测试建议

### 1. 基本功能测试
- ✅ 完成蓝牙 OOB 配对
- ✅ 等待自动跳转到文件选择页面
- ✅ 选择文件进行传输
- ✅ 验证不再出现"蓝牙未连接"错误

### 2. 时序测试
- ✅ 配对完成后立即观察日志
- ✅ 确认 Socket 连接成功后才跳转
- ✅ 验证跳转时机正确

### 3. 边界情况测试
- ✅ 测试连接失败的情况
- ✅ 测试连接超时的情况
- ✅ 测试不同 Android 版本
- ✅ 测试不同设备型号

### 4. 错误场景测试
- ✅ 在未配对时尝试传输（应正确提示）
- ✅ 在传输过程中断开连接（应正确处理）
- ✅ Socket 连接失败时的错误提示

## 技术说明

### 为什么通过流验证更可靠？

1. **直接验证可用性**
   - `inputStream` 和 `outputStream` 是实际传输数据所需的
   - 如果能获取到流，说明连接确实可用

2. **避免状态同步问题**
   - 不依赖 Socket 内部的状态标志
   - 直接测试实际功能

3. **更好的错误检测**
   - 如果连接有问题，获取流时会抛出异常
   - 可以捕获并提供详细的错误信息

### 异步连接的处理

1. **配对完成 ≠ Socket 连接完成**
   - 配对只是建立了设备间的信任关系
   - Socket 连接需要额外的时间建立

2. **回调机制**
   - 使用 `BluetoothStateListener` 监听连接状态
   - 在 `onDeviceConnected()` 回调中确认连接成功

3. **UI 状态同步**
   - 通过 `isNfcConnected` 状态变量同步
   - `HomeScreen` 的 `LaunchedEffect` 监听状态变化
   - 确保 UI 跳转时机正确

## 总结

这个修复解决了两个关键问题：

1. **异步连接时序问题**：确保只有在 Socket 真正连接成功后才跳转到文件选择页面
2. **连接状态检测问题**：使用更可靠的流验证方式替代不可靠的 `isConnected` 方法

通过这些改进，应用现在能够正确处理蓝牙连接的异步特性，确保用户在选择文件时 Socket 已经就绪，从而避免"蓝牙未连接"的错误提示。